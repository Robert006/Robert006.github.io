[{"title":"js实现集合(Set类)","date":"2018-10-06T07:27:04.000Z","path":"2018/10/js实现集合-Set类/","text":"集合是由一组无序且唯一的项组成的。这个数据结构使用了与有限集合相同的数学概念,但应用在计算机科学的数据结构中。ECMAScript 6 包括了Set类的实现。Set实例的属性和方法属性：Set.prototype.constructor：构造函数，默认就是Set函数Set.prototype.size：返回实例包含的元素的数量，与数组的length属性相似操作方法：add(value)：添加新的项，返回Set结构本身delete(value)：删除某项，返回布尔值has(value)：返回一个布尔值，表示该值在Set中存在与否clear()：移除Set对象内的所有元素。无返回值遍历方法：keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员ok,为了加深理解，我们自己实现其中的一些方法，Set类的实现如下：12345678910111213141516171819202122232425262728293031323334353637383940function Set(param) &#123; \"use strict\"; var item = param || []; var arr = []; for (let i = 0; i &lt; item.length; i++) &#123; if (!arr.includes(item[i])) &#123; arr.push(item[i]) &#125; &#125; this.elements = arr; this.size = arr.length;&#125;Set.prototype.add = function (val) &#123; if (!this.has(val)) &#123; this.elements.push(val); this.size++; &#125; return this.elements;&#125;Set.prototype.has = function (val) &#123; return this.elements.includes(val);&#125;Set.prototype.delete = function (val) &#123; if (this.has(val)) &#123; let idx = this.elements.indexOf(val); this.elements.splice(idx, 1); this.size--; return true; &#125; else &#123; return false; &#125;&#125;Set.prototype.clear = function () &#123; this.elements = []; this.size = 0; return this.elements;&#125;Set.prototype.values = function () &#123; return this.elements;&#125;应用数组去重 用法如下：1234var arr = [1,1,3,undefined,undefined,null,NaN,null,NaN,&#123;name:'hi'&#125;,&#123;name:'hi'&#125;];var unique = Array.from(new Set(arr));console.log(unique);// [1, 3, undefined, null, NaN, &#123;…&#125;, &#123;…&#125;]参考学习JavaScript数据结构和算法 Loiane GronerES6的Set数据结构Set - JavaScript | MDN","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"Set","slug":"Set","permalink":"http://yoursite.com/tags/Set/"}]},{"title":"js实现个链表吧","date":"2018-10-05T07:30:43.000Z","path":"2018/10/js实现个链表吧/","text":"存储多个元素，最常用的数据结构是数组。但是数组有个一缺点，从数组中添加或移除项的成本很高，因为需要移动元素。链表也可以存储有序的元素集合，但是和数组不同，链表中的元素在内存中不是连续放置的。每个元素存储本身节点值和下一个元素的引用，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。ok,开始实现我们的数据结构，骨架如下12345678910111213141516 function LinkedList() &#123; var Node = function (val) &#123; this.val = val; this.next = null; &#125;; //Node辅助类 var length = 0; var head = null; this.append = function (ele) &#123;&#125;; //追加 this.insert = function (pos, ele) &#123;&#125;; //插入 this.removeAt = function (pos) &#123;&#125;; //移除 this.indexOf = function (ele) &#123;&#125;; //查找元素 this.isEmpty = function () &#123;&#125;; //是否为空 this.size = function () &#123;&#125;; //链表元素个数 this.getHead = function () &#123;&#125;; //链表头 this.toString = function () &#123;&#125;; //转换为字符串&#125;首先实现向链表尾部追加元素吧：12345678910111213141516this.append = function (ele) &#123; var node = new Node(ele), current; if (head == null) &#123; head = node; &#125; else &#123; current = head; //找到最后一项 while (current.next) &#123; current = current.next; &#125; //将最后一项的next指向 node current.next = node; &#125; length++; //更新链表长度&#125;继续实现链表插入12345678910111213141516171819202122232425this.insert = function (pos, ele) &#123; var node = new Node(ele); var idx = 0, previous, current = head; // 检查是否越界 if (pos &gt;= 0 &amp;&amp; pos &lt;= length) &#123; if (pos === 0) &#123; node.next = current; head = node; &#125; else &#123; while (idx &lt; pos) &#123; previous = current; //保存前一个节点的引用 current = current.next; idx++; &#125; node.next = current; //节点的next指向current previous.next = node; //前一个节点指向node length++; //更新数组长度 &#125; &#125; else &#123; return false; &#125;&#125;链表的移除：12345678910111213141516171819202122this.removeAt = function (pos) &#123; var current = head; var idx = 0, previous; //检查越界 if (pos &gt;= 0 &amp;&amp; pos &lt;= length) &#123; if (pos === 0) &#123; head = current.next; &#125; else &#123; while (idx &lt; pos) &#123; previous = current; current = current.next; idx++; &#125; previous.next = current.next; //前一个节点指向下一个节点 &#125; length--; //更新链表长度 return current.val; &#125; else &#123; return null &#125;&#125;其他方法就比较简单了，实现如下:123456789101112131415161718this.isEmpty = function () &#123; return !length;&#125;this.size = function () &#123; return length;&#125;this.getHead = function () &#123; return head;&#125;this.toString = function () &#123; var str = ''; var current = head; while (current) &#123; str = str + ',' + current.val; current = current.next; &#125; return str.slice(1);&#125;参考学习JavaScript数据结构和算法 Loiane Groner","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"井字棋游戏","date":"2017-12-24T07:58:01.000Z","path":"2017/12/井字棋游戏/","text":"","tags":[]},{"title":"Hello World","date":"2017-12-17T08:49:37.158Z","path":"2017/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","tags":[]}]