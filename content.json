[{"title":"flex布局学习总结","date":"2018-12-09T10:33:57.000Z","path":"2018/12/flex布局学习总结/","text":"最近项目主要是小程序，小程序里面的布局主要采用flex布局，之前对flex 布局只是稍作了解，总结下flex 布局的常用套路容器Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。像这样:.container{ display: flex; } 轴(Axis)每个弹性框布局包含两个轴。弹性项目沿其依次排列的那根轴称为主轴(main axis)。垂直于主轴的那根轴称为侧轴(cross axis)。flex-direction 确立主轴。justify-content 定义了在当前行上，弹性项目沿主轴如何排布。align-items 定义了在当前行上，弹性项目沿侧轴默认如何排布。align-self 定义了单个弹性项目在侧轴上应当如何对齐，这个定义会覆盖由 align-items 所确立的默认值。方向(Direction)弹性容器的主轴起点(main start)/主轴终点(main end)和侧轴起点(cross start)/侧轴终点(cross end)描述了弹性项目排布的起点与终点。它们具体取决于弹性容器的主轴与侧轴中，由 writing-mode 确立的方向（从左到右、从右到左，等等）。order 属性将元素与序号关联起来，以此决定哪些元素先出现。flex-flow 属性是 flex-direction 和 flex-wrap 属性的简写，决定弹性项目如何排布。行(Line)根据 flex-wrap 属性，弹性项目可以排布在单个行或者多个行中。此属性控制侧轴的方向和新行排列的方向。尺寸(Dimension)根据弹性容器的主轴与侧轴，弹性项目的宽和高中，对应主轴的称为主轴尺寸(main size) ，对应侧轴的称为 侧轴尺寸(cross size)。min-height 与 min-width 属性初始值将为 0。flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写，描述弹性项目的整体的伸缩性CSS属性flex规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间。这是一个简写属性，用来设置flex-grow, flex-shrink与flex-basis。大多数情况下，开发者需要将flex设置为auto，initial，none，或一个无单位正数auto元素会根据自身的宽度与高度来确定尺寸，但是会自行伸长以吸收flex容器中额外的自由空间，也会缩短至自身最小尺寸以适应容器。这相当于将属性设置为 “flex: 1 1 auto”.initial属性默认值， 元素会根据自身宽高设置尺寸。它会缩短自身以适应容器，但不会伸长并吸收flex容器中的额外自由空间来适应容器 。相当于将属性设置为”flex: 0 1 auto”。none元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应flex容器。相当于将属性设置为”flex: 0 0 auto”。参考flex [MDN]Flex 布局语法教程","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"css实现椭圆","date":"2018-10-31T07:12:10.000Z","path":"2018/10/css实现椭圆/","text":"先实现个简单点的，用css实现一个圆，ok，直接上代码：123456.circle&#123; width: 100px; height:100px; background: red; border-radius: 50%;&#125;实现椭圆的方法1.利用css3变形1234567.circle&#123; width: 100px; height:100px; background: red; border-radius: 50%; transform: scale(1,0.5);&#125;效果如下2.直接改变高度123456.circle&#123; width: 100px; height:50px; background: red; border-radius: 50%;&#125;效果如下3.利用border-radius属性123456789.circle&#123; width: 100px; height:100px; background: red; border-top-left-radius:100px 50px; border-top-right-radius:100px 50px; border-bottom-left-radius:100px 50px; border-bottom-right-radius:100px 50px;&#125;效果如下但是这样实现的效果还不是椭圆，还要再把高度设置为宽度的一半，所以还是直接用第二种方法比较简便参考border-radius[MDN]CSS3 border-radius知多少css实现椭圆、半椭圆","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"js实现欧几里得算法","date":"2018-10-16T11:23:22.000Z","path":"2018/10/js实现欧几里得算法/","text":"概念在数学中，辗转相除法，又称欧几里得算法（英语：Euclidean algorithm），是求最大公约数的算法。证明首先假设有两个数a和b,其中a是不小于b的数，记a被b除的余数为r,那么a可以写成这样的形式：a = b*q + r假设a和b的一个约数为u，那么a和b都能被u整除,即：12a = sub = tu带入原式可得123su = (tu)*q + rr = su - (tu)*qr = u*(s-tq)所以 u 也是r 的公约数,即a和b的约数也整除它们的余数r，所以a和b的任一约数同时也是b和r的约数。同理可证明b和r的任一公约数也是a的公约数。假设b和r的任一公约数为 v,则有：12b = mvr = nv带入原式可得12a = (mv)*q + nva = v*(mq+n)所以a和b的约数组成的集合与b和r的约数集合是相等的，那么a和b的最大约数和b和r的最大约数也相等。实现用js实现代码如下：12345678910function gcd(a,b)&#123; let max = a&gt;b?a:b; let min = a&gt;b?b:a; let r = max%min; if(r==0)&#123; return min; &#125;else&#123; return gcd(min,r) &#125;&#125;简化版本如下：function gcd(a,b){ return b===0?a:gcd(b,a%b); } 参考辗转相除法[维基百科]欧几里得算法求最大公约数的数学原理js实现欧几里得算法/辗转相除法","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"js数组的方法小结","date":"2018-10-09T12:44:19.000Z","path":"2018/10/js数组的方法小结/","text":"js中数组是一种非常常用数据结构，而且很容易模拟其他的一些数据结构，比如栈和队列。数组的原型Array.prototype内置了很多方法，下面就来小小总结一下这些方法。检测数组就不用多说了，使用ECMAScript5新增的Array.isArray()即可转换方法toLocaleString() toString() join() 和 valueOf()所有对象都有toLocaleString() toString() 和 valueOf() 方法，其中调用数组的toString()方法会返回数组每个值得字符串形式拼接而成的一个以逗号分隔的字符串。而valueOf()返回的还是数组。1234var arr = [1,2,4];console.log(arr.toString()) // 1,2,4console.log(arr.toLocaleString()) // 1,2,4console.log(arr.valueOf()) // [1,2,4]join()可以使用不同分隔符构建字符串，只接受一个参数，即用做分割符的字符串，返回包含数组所以项的字符串12var say = ['h','e','l','l','o'];say.join('-'); //\"h-e-l-l-o\"栈方法push() 和 pop()栈是一种后进先出（LIFO）的数据结构,栈中项的插入和移除都发生在一个位置——栈顶。ECMAScript为数组专门提供了push() 和 pop()方法，实现类似栈的行为。push() 方法接受任意数量的参数，把他们逐个添加在数组末尾，返回修改后的数组长度。pop() 方法从数组末尾移除最后一项，减少数组length值，返回移除的项1234var stack = [];console.log(stack.push(3,5,6)) // 3console.log(stack.push(8)) // 4console.log(stack.pop()) // 8队列方法push() 和 shift()队列是一种先进先出（FIFO）的数据结构，由于push()是向数组末尾添加项，因此要模拟队列只需要一个从数组前端取得项的方法。实现这一操作的数组方法是shift()，他可以移除数组中的第一项并返回该项。1234var queue = [];console.log(queue.push(3,5,6)) // 3console.log(queue.push(8)) // 4console.log(queue.shift()) // 3*tips: ECMAScript为数组还提供了一个unshift()方法，其用途与shift()相反，他能在数组前端添加任意个项并返回新数组的长度。同时使用 unshift()和 pop()方法，可以从反方向模拟队列。重排序方法reverse() 和 sort()reverse() 会反转数组的顺序，返回反转后的数组。但是不够灵活，所以有了sort()方法。默认情况下，sort()按升序排列数组。最小值在最前面，为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串确定如何排序。这种排序方法通常不是最佳方案，因此sort()方法可以接受一个比较函数，以便我们指定哪个值位于哪个值的前面。比如从小到大排序，可以如下操作：1234var nums = [1,3,15,9,6,10,2];nums.sort(function(before,next)&#123; return before-next;&#125;); // [1, 2, 3, 6, 9, 10, 15]操作方法concat() slice() 和 splice()concat()可以拼接数组，没有参数情况下，复制当前数组返回副本，如果参数是一个或多个数组，该方法会将数组的每一项都添加到结果数组中。如果参数不是数组，这些值会被简单的添加到结果数组的末尾。slice()方法可以基于当前数组中的一个或多个项创建新的数组（前闭后开区间），如果不传参数，也会复制当前数组返回副本。 concat() 和 slice() 均不改变原数组。splice()就比较厉害了，是很强大的数组处理方法，可以用来删除、插入、和替换。第一个参数指定开始删除的位置，第二个参数删除的项数，第三个及以后的参数是要插入的项。123var nums = [1,2,4,5,6];nums.splice(2,0,3);console.log(nums) // [1, 2, 3, 4, 5, 6]位置方法indexOf() 和 lastIndexOf()这两方法都接收两个参数，要查找的项和开始查找的位置（可选）。indexOf()从数组开头位置查找，lastIndexOf() 从数组末尾查找。查找时和数组每一项严格相等比较（===），如果查到,就返回查找项在数组中的位置，查不到就返回-1.123var nums = [1,2,4,5,6];nums.indexOf(5); // 3nums.indexOf(9); // -1迭代方法every() filter() forEach() map() some()ECMAScript5 提供了5个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象——影响this的值。传入的函数会接收三个参数：数组项的值，该项在数组的位置，数组对象本身。这5个方法有各自不同的作用：every()： 数组每一项运行给定函数，如果该函数每一项都返回true，则返回truesome()： 数组每一项运行给定函数，如果该函数任意一项都返回true，则返回truefilter()： 数组每一项运行给定函数，返回该函数会返回true的项组成的数组forEach()： 数组每一项运行给定函数，该方法无返回值map()： 数组每一项运行给定函数，返回该函数每次调用的结果组成的数组以上方法不会改变原数组的值12345var arr = [1,2,3,4,5,6,7]var plus10=arr.map(function(item)&#123; return item+10;&#125;);console.log(plus10) // [11, 12, 13, 14, 15, 16, 17]归并方法reduce() 和 reduceRight()这两个方法都迭代所有项，然后构建一个最终返回值。reduce()从数组开头迭代，reduceRight() 从数组末尾迭代。接收两个参数，在每一项上调用的函数和（可选）作为归并基础的初始值。调用函数接收4个参数：前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都作为第一个参数自动传给下一项。比如累加操作：12345var arr = [1,2,3,4,5,6,7,8,9,10]var sum=arr.reduce(function(pre,cur)&#123; return pre+cur;&#125;);console.log(sum) // 55ES6+ 新增方法entries() fill() findIndex() includes()entries()方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。123456789101112var array = ['a', 'b', 'c'];var iterator = array.entries();console.log(iterator.next().value);// [0, \"a\"]console.log(iterator.next().value);// [1, \"b\"]for (let e of iterator) &#123; console.log(e);&#125;// [0, \"a\"] // [1, \"b\"] // [2, \"c\"]fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。(前闭后开)fill 方法接受三个参数 value, start 以及 end. start 和 end 参数是可选的, 其默认值分别为 0 和 this 对象的 length属性值; fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。1234var array = [1, 2, 3, 4];// fill with 0 from position 2 until position 4console.log(array1.fill('fill', 2, 4)); // [1, 2, \"fill\", \"fill\"]console.log(array); // [1, 2, \"fill\", \"fill\"]find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。find 方法对数组中的每一项元素执行一次 callback 函数,callback 函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。findIndex()用法和他一样，不同的是findIndex()返回数组中找到的元素的索引，而不是其值。如果找不到，则返回-1。123456789var inventory = [ &#123;name: 'apples', quantity: 2&#125;, &#123;name: 'bananas', quantity: 0&#125;, &#123;name: 'cherries', quantity: 5&#125;];function findCherries(fruit) &#123; return fruit.name === 'cherries';&#125;console.log(inventory.find(findCherries)); // &#123; name: 'cherries', quantity: 5 &#125;includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。123456var array1 = [1, 2, 3];console.log(array1.includes(2));// truevar pets = ['cat', 'dog', 'bat'];console.log(pets.includes('cat'));// trueincludes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的arguments对象上调用的includes() 方法。1234(function() &#123; console.log([].includes.call(arguments, 'a')); // true console.log([].includes.call(arguments, 'd')); // false&#125;)('a','b','c');实验中的功能flat()flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。123456789var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]参考JavaScript高级程序设计（第三版） Nicholas C.ZakasArray.prototype.entries() | MDNArray.prototype.fill() | MDNArray.prototype.find() | MDNArray.prototype.flat() | MDNArray.prototype.includes() | MDN","tags":[{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"js实现集合(Set类)","date":"2018-10-06T07:27:04.000Z","path":"2018/10/js实现集合-Set类/","text":"集合是由一组无序且唯一的项组成的。这个数据结构使用了与有限集合相同的数学概念,但应用在计算机科学的数据结构中。ECMAScript 6 包括了Set类的实现。Set实例的属性和方法属性：Set.prototype.constructor：构造函数，默认就是Set函数Set.prototype.size：返回实例包含的元素的数量，与数组的length属性相似操作方法：add(value)：添加新的项，返回Set结构本身delete(value)：删除某项，返回布尔值has(value)：返回一个布尔值，表示该值在Set中存在与否clear()：移除Set对象内的所有元素。无返回值遍历方法：keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员ok,为了加深理解，我们自己实现其中的一些方法，Set类的实现如下：12345678910111213141516171819202122232425262728293031323334353637383940function Set(param) &#123; \"use strict\"; var item = param || []; var arr = []; for (let i = 0; i &lt; item.length; i++) &#123; if (!arr.includes(item[i])) &#123; arr.push(item[i]) &#125; &#125; this.elements = arr; this.size = arr.length;&#125;Set.prototype.add = function (val) &#123; if (!this.has(val)) &#123; this.elements.push(val); this.size++; &#125; return this.elements;&#125;Set.prototype.has = function (val) &#123; return this.elements.includes(val);&#125;Set.prototype.delete = function (val) &#123; if (this.has(val)) &#123; let idx = this.elements.indexOf(val); this.elements.splice(idx, 1); this.size--; return true; &#125; else &#123; return false; &#125;&#125;Set.prototype.clear = function () &#123; this.elements = []; this.size = 0; return this.elements;&#125;Set.prototype.values = function () &#123; return this.elements;&#125;应用数组去重 用法如下：1234var arr = [1,1,3,undefined,undefined,null,NaN,null,NaN,&#123;name:'hi'&#125;,&#123;name:'hi'&#125;];var unique = Array.from(new Set(arr));console.log(unique);// [1, 3, undefined, null, NaN, &#123;…&#125;, &#123;…&#125;]参考学习JavaScript数据结构和算法 Loiane GronerES6的Set数据结构Set - JavaScript | MDN","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"Set","slug":"Set","permalink":"http://yoursite.com/tags/Set/"}]},{"title":"js实现个链表吧","date":"2018-10-05T07:30:43.000Z","path":"2018/10/js实现个链表吧/","text":"存储多个元素，最常用的数据结构是数组。但是数组有个一缺点，从数组中添加或移除项的成本很高，因为需要移动元素。链表也可以存储有序的元素集合，但是和数组不同，链表中的元素在内存中不是连续放置的。每个元素存储本身节点值和下一个元素的引用，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。ok,开始实现我们的数据结构，骨架如下12345678910111213141516 function LinkedList() &#123; var Node = function (val) &#123; this.val = val; this.next = null; &#125;; //Node辅助类 var length = 0; var head = null; this.append = function (ele) &#123;&#125;; //追加 this.insert = function (pos, ele) &#123;&#125;; //插入 this.removeAt = function (pos) &#123;&#125;; //移除 this.indexOf = function (ele) &#123;&#125;; //查找元素 this.isEmpty = function () &#123;&#125;; //是否为空 this.size = function () &#123;&#125;; //链表元素个数 this.getHead = function () &#123;&#125;; //链表头 this.toString = function () &#123;&#125;; //转换为字符串&#125;首先实现向链表尾部追加元素吧：12345678910111213141516this.append = function (ele) &#123; var node = new Node(ele), current; if (head == null) &#123; head = node; &#125; else &#123; current = head; //找到最后一项 while (current.next) &#123; current = current.next; &#125; //将最后一项的next指向 node current.next = node; &#125; length++; //更新链表长度&#125;继续实现链表插入12345678910111213141516171819202122232425this.insert = function (pos, ele) &#123; var node = new Node(ele); var idx = 0, previous, current = head; // 检查是否越界 if (pos &gt;= 0 &amp;&amp; pos &lt;= length) &#123; if (pos === 0) &#123; node.next = current; head = node; &#125; else &#123; while (idx &lt; pos) &#123; previous = current; //保存前一个节点的引用 current = current.next; idx++; &#125; node.next = current; //节点的next指向current previous.next = node; //前一个节点指向node length++; //更新数组长度 &#125; &#125; else &#123; return false; &#125;&#125;链表的移除：12345678910111213141516171819202122this.removeAt = function (pos) &#123; var current = head; var idx = 0, previous; //检查越界 if (pos &gt;= 0 &amp;&amp; pos &lt;= length) &#123; if (pos === 0) &#123; head = current.next; &#125; else &#123; while (idx &lt; pos) &#123; previous = current; current = current.next; idx++; &#125; previous.next = current.next; //前一个节点指向下一个节点 &#125; length--; //更新链表长度 return current.val; &#125; else &#123; return null &#125;&#125;其他方法就比较简单了，实现如下:123456789101112131415161718this.isEmpty = function () &#123; return !length;&#125;this.size = function () &#123; return length;&#125;this.getHead = function () &#123; return head;&#125;this.toString = function () &#123; var str = ''; var current = head; while (current) &#123; str = str + ',' + current.val; current = current.next; &#125; return str.slice(1);&#125;参考学习JavaScript数据结构和算法 Loiane Groner","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"井字棋游戏","date":"2017-12-24T07:58:01.000Z","path":"2017/12/井字棋游戏/","text":"","tags":[]},{"title":"Hello World","date":"2017-12-17T08:49:37.158Z","path":"2017/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","tags":[]}]