<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="web, font-end development"><title>js数组的方法小结 | robert</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">js数组的方法小结</h1><a id="logo" href="/.">robert</a><p class="description">yesterday you said tomorrow</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home">Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="keywords"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">js数组的方法小结</h1><div class="post-meta"><a href="/2018/10/js数组的方法小结/#comments" class="comment-count"></a><p><span class="date">Oct 09, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><p>js中数组是一种非常常用数据结构，而且很容易模拟其他的一些数据结构，比如栈和队列。数组的原型<code>Array.prototype</code>内置了很多方法，下面就来小小总结一下这些方法。<a id="more"></a><br>检测数组就不用多说了，使用ECMAScript5新增的<code>Array.isArray()</code>即可</p><h1 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h1><h2 id="toLocaleString-toString-join-和-valueOf"><a href="#toLocaleString-toString-join-和-valueOf" class="headerlink" title="toLocaleString()  toString() join() 和 valueOf()"></a><code>toLocaleString()</code> <code>toString()</code> <code>join()</code> 和 <code>valueOf()</code></h2><blockquote><p>所有对象都有<code>toLocaleString()</code> <code>toString()</code> 和 <code>valueOf()</code> 方法，其中调用数组的<code>toString()</code>方法会返回数组每个值得字符串形式拼接而成的一个以逗号分隔的字符串。而<code>valueOf()</code>返回的还是数组。</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [1,2,4];</span><br><span class="line">console.<span class="built_in">log</span>(arr.<span class="keyword">toString</span>())  <span class="comment">// 1,2,4</span></span><br><span class="line">console.<span class="built_in">log</span>(arr.toLocaleString())  <span class="comment">// 1,2,4</span></span><br><span class="line">console.<span class="built_in">log</span>(arr.valueOf())  <span class="comment">// [1,2,4]</span></span><br></pre></td></tr></table></figure><blockquote><p><code>join()</code>可以使用不同分隔符构建字符串，只接受一个参数，即用做分割符的字符串，返回包含数组所以项的字符串</p></blockquote><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">say</span> = [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>];</span><br><span class="line"><span class="built_in">say</span>.<span class="built_in">join</span>(<span class="string">'-'</span>);  <span class="comment">//"h-e-l-l-o"</span></span><br></pre></td></tr></table></figure><h1 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h1><h2 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push() 和 pop()"></a><code>push()</code> 和 <code>pop()</code></h2><blockquote><p>栈是一种后进先出（LIFO）的数据结构,栈中项的插入和移除都发生在一个位置——栈顶。ECMAScript为数组专门提供了<code>push()</code> 和 <code>pop()</code>方法，实现类似栈的行为。</p><ul><li><code>push()</code> 方法接受任意数量的参数，把他们逐个添加在数组末尾，返回修改后的数组长度。</li><li><code>pop()</code> 方法从数组末尾移除最后一项，减少数组<code>length</code>值，返回移除的项</li></ul></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">stack</span> = [];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.push(3,5,6)) <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.push(8))  <span class="comment">// 4</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">stack</span>.pop())  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><h2 id="push-和-shift"><a href="#push-和-shift" class="headerlink" title="push() 和 shift()"></a><code>push()</code> 和 <code>shift()</code></h2><blockquote><p>队列是一种先进先出（FIFO）的数据结构，由于<code>push()</code>是向数组末尾添加项，因此要模拟队列只需要一个从数组前端取得项的方法。实现这一操作的数组方法是<code>shift()</code>，他可以移除数组中的第一项并返回该项。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">queue</span> = [];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">queue</span>.push(<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>)) <span class="comment">// 3</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">queue</span>.push(<span class="number">8</span>))  <span class="comment">// 4</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">queue</span>.shift())  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>*tips: ECMAScript为数组还提供了一个<code>unshift()</code>方法，其用途与<code>shift()</code>相反，他能在数组前端添加任意个项并返回新数组的长度。同时使用 <code>unshift()</code>和 <code>pop()</code>方法，可以从反方向模拟队列。</p><h1 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h1><h2 id="reverse-和-sort"><a href="#reverse-和-sort" class="headerlink" title="reverse() 和 sort()"></a><code>reverse()</code> 和 <code>sort()</code></h2><blockquote><p><code>reverse()</code> 会反转数组的顺序，返回反转后的数组。但是不够灵活，所以有了<code>sort()</code>方法。默认情况下，<code>sort()</code>按升序排列数组。最小值在最前面，为了实现排序，<code>sort()</code>方法会调用每个数组项的<code>toString()</code>转型方法，然后比较得到的字符串确定如何排序。这种排序方法通常不是最佳方案，因此<code>sort()</code>方法可以接受一个比较函数，以便我们指定哪个值位于哪个值的前面。比如从小到大排序，可以如下操作：</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>];</span><br><span class="line">nums.sort(function(before,next)&#123;</span><br><span class="line">    return before-next;</span><br><span class="line">&#125;); <span class="comment">// [1, 2, 3, 6, 9, 10, 15]</span></span><br></pre></td></tr></table></figure><h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><h2 id="concat-slice-和-splice"><a href="#concat-slice-和-splice" class="headerlink" title="concat() slice() 和 splice()"></a><code>concat()</code> <code>slice()</code> 和 <code>splice()</code></h2><blockquote><p><code>concat()</code>可以拼接数组，没有参数情况下，复制当前数组返回副本，如果参数是一个或多个数组，该方法会将数组的每一项都添加到结果数组中。如果参数不是数组，这些值会被简单的添加到结果数组的末尾。<br><code>slice()</code>方法可以基于当前数组中的一个或多个项创建新的数组（前闭后开区间），如果不传参数，也会复制当前数组返回副本。 <code>concat()</code> 和 <code>slice()</code> 均不改变原数组。<br><code>splice()</code>就比较厉害了，是很强大的数组处理方法，可以用来删除、插入、和替换。第一个参数指定开始删除的位置，第二个参数删除的项数，第三个及以后的参数是要插入的项。</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">nums.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">console.log(nums) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h1 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h1><h2 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a><code>indexOf()</code> 和 <code>lastIndexOf()</code></h2><blockquote><p>这两方法都接收两个参数，要查找的项和开始查找的位置（可选）。<code>indexOf()</code>从数组开头位置查找，<code>lastIndexOf()</code> 从数组末尾查找。查找时和数组每一项严格相等比较（===），如果查到,就返回查找项在数组中的位置，查不到就返回-1.</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">nums.indexOf(<span class="number">5</span>);  <span class="comment">// 3</span></span><br><span class="line">nums.indexOf(<span class="number">9</span>);  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h1 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h1><h2 id="every-filter-forEach-map-some"><a href="#every-filter-forEach-map-some" class="headerlink" title="every() filter() forEach() map() some()"></a><code>every()</code> <code>filter()</code> <code>forEach()</code> <code>map()</code> <code>some()</code></h2><blockquote><p>ECMAScript5 提供了5个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象——影响<code>this</code>的值。传入的函数会接收三个参数：数组项的值，该项在数组的位置，数组对象本身。这5个方法有各自不同的作用：</p><ul><li><code>every()</code>： 数组每一项运行给定函数，如果该函数每一项都返回<code>true</code>，则返回<code>true</code></li><li><code>some()</code>： 数组每一项运行给定函数，如果该函数任意一项都返回<code>true</code>，则返回<code>true</code></li><li><code>filter()</code>： 数组每一项运行给定函数，返回该函数会返回<code>true</code>的项组成的数组</li><li><code>forEach()</code>： 数组每一项运行给定函数，该方法无返回值</li><li><code>map()</code>： 数组每一项运行给定函数，返回该函数每次调用的结果组成的数组<br>以上方法不会改变原数组的值</li></ul></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">var plus10=arr.map(function(item)&#123;</span><br><span class="line">   return item+<span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(plus10) <span class="comment">// [11, 12, 13, 14, 15, 16, 17]</span></span><br></pre></td></tr></table></figure><h1 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h1><h2 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce() 和 reduceRight()"></a><code>reduce()</code> 和 <code>reduceRight()</code></h2><blockquote><p>这两个方法都迭代所有项，然后构建一个最终返回值。<code>reduce()</code>从数组开头迭代，<code>reduceRight()</code> 从数组末尾迭代。接收两个参数，在每一项上调用的函数和（可选）作为归并基础的初始值。调用函数接收4个参数：前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都作为第一个参数自动传给下一项。比如累加操作：</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">var sum=arr.reduce(function(pre,cur)&#123;</span><br><span class="line">   return pre+cur;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(sum) <span class="comment">// 55</span></span><br></pre></td></tr></table></figure><h1 id="ES6-新增方法"><a href="#ES6-新增方法" class="headerlink" title="ES6+ 新增方法"></a>ES6+ 新增方法</h1><h2 id="entries-fill-findIndex-includes"><a href="#entries-fill-findIndex-includes" class="headerlink" title="entries() fill() findIndex() includes()"></a><code>entries()</code> <code>fill()</code> <code>findIndex()</code> <code>includes()</code></h2><blockquote><p><code>entries()</code>方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。</p></blockquote><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">array</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">iterator</span> = <span class="keyword">array</span>.entries();</span><br><span class="line">console.log(<span class="keyword">iterator</span>.next().value);</span><br><span class="line"><span class="comment">// [0, "a"]</span></span><br><span class="line">console.log(<span class="keyword">iterator</span>.next().value);</span><br><span class="line"><span class="comment">// [1, "b"]</span></span><br><span class="line"><span class="keyword">for</span> (let e <span class="keyword">of</span> <span class="keyword">iterator</span>) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    console.log(e);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// [0, "a"] </span></span><br><span class="line"><span class="comment">// [1, "b"] </span></span><br><span class="line"><span class="comment">// [2, "c"]</span></span><br></pre></td></tr></table></figure><blockquote><p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。(前闭后开)<br><code>fill</code> 方法接受三个参数 <code>value</code>, <code>start</code> 以及 <code>end</code>. <code>start</code> 和 <code>end</code> 参数是可选的, 其默认值分别为 <code>0</code> 和 <code>this</code> 对象的 <code>length</code>属性值; <code>fill</code> 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。</p></blockquote><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var<span class="built_in"> array </span>= [1, 2, 3, 4];</span><br><span class="line">//<span class="built_in"> fill </span>with 0 from position 2 until position 4</span><br><span class="line">console.log(array1.fill('fill', 2, 4)); // [1, 2, <span class="string">"fill"</span>, <span class="string">"fill"</span>]</span><br><span class="line">console.log(array); // [1, 2, <span class="string">"fill"</span>, <span class="string">"fill"</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <code>undefined</code>。<code>find</code> 方法对数组中的每一项元素执行一次 <code>callback</code> 函数,<code>callback</code> 函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。<br><code>findIndex()</code>用法和他一样，不同的是<code>findIndex()</code>返回数组中找到的元素的索引，而不是其值。如果找不到，则返回-1。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var inventory = [</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'apples'</span>, <span class="string">quantity:</span> <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'bananas'</span>, <span class="string">quantity:</span> <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'cherries'</span>, <span class="string">quantity:</span> <span class="number">5</span>&#125;</span><br><span class="line">];</span><br><span class="line">function findCherries(fruit) &#123; </span><br><span class="line">    <span class="keyword">return</span> fruit.name === <span class="string">'cherries'</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.log(inventory.find(findCherries));  <span class="comment">// &#123; name: 'cherries', quantity: 5 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回<code>false</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array1.includes(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//  true</span></span><br><span class="line"><span class="keyword">var</span> pets = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'cat'</span>));</span><br><span class="line"><span class="comment">//  true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>includes()</code> 方法有意设计为通用方法。它不要求<code>this</code>值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的<code>arguments</code>对象上调用的<code>includes()</code> 方法。</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">function</span>() &#123;</span><br><span class="line">  console.log([].includes.call(<span class="name">arguments</span>, <span class="symbol">'a</span>'))<span class="comment">; // true</span></span><br><span class="line">  console.log([].includes.call(<span class="name">arguments</span>, <span class="symbol">'d</span>'))<span class="comment">; // false</span></span><br><span class="line">&#125;)(<span class="symbol">'a</span>',<span class="symbol">'b</span>',<span class="symbol">'c</span>')<span class="comment">;</span></span><br></pre></td></tr></table></figure><h1 id="实验中的功能"><a href="#实验中的功能" class="headerlink" title="实验中的功能"></a>实验中的功能</h1><h2 id="flat"><a href="#flat" class="headerlink" title="flat()"></a><code>flat()</code></h2><blockquote><p>flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">var arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line">var arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr3.flat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>JavaScript高级程序设计（第三版） Nicholas C.Zakas</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries" target="_blank" rel="noopener">Array.prototype.entries() | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noopener">Array.prototype.fill() | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">Array.prototype.find() | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">Array.prototype.flat() | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="noopener">Array.prototype.includes() | MDN</a></li></ul></div><div class="tags"><a href="/tags/数组/">数组</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/10/js实现欧几里得算法/" class="pre">js实现欧几里得算法</a><a href="/2018/10/js实现集合-Set类/" class="next">js实现集合(Set类)</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#转换方法"><span class="toc-number">1.</span> <span class="toc-text">转换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#toLocaleString-toString-join-和-valueOf"><span class="toc-number">1.1.</span> <span class="toc-text">toLocaleString() toString() join() 和 valueOf()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈方法"><span class="toc-number">2.</span> <span class="toc-text">栈方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#push-和-pop"><span class="toc-number">2.1.</span> <span class="toc-text">push() 和 pop()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列方法"><span class="toc-number">3.</span> <span class="toc-text">队列方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#push-和-shift"><span class="toc-number">3.1.</span> <span class="toc-text">push() 和 shift()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重排序方法"><span class="toc-number">4.</span> <span class="toc-text">重排序方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reverse-和-sort"><span class="toc-number">4.1.</span> <span class="toc-text">reverse() 和 sort()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作方法"><span class="toc-number">5.</span> <span class="toc-text">操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#concat-slice-和-splice"><span class="toc-number">5.1.</span> <span class="toc-text">concat() slice() 和 splice()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#位置方法"><span class="toc-number">6.</span> <span class="toc-text">位置方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#indexOf-和-lastIndexOf"><span class="toc-number">6.1.</span> <span class="toc-text">indexOf() 和 lastIndexOf()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迭代方法"><span class="toc-number">7.</span> <span class="toc-text">迭代方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#every-filter-forEach-map-some"><span class="toc-number">7.1.</span> <span class="toc-text">every() filter() forEach() map() some()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#归并方法"><span class="toc-number">8.</span> <span class="toc-text">归并方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reduce-和-reduceRight"><span class="toc-number">8.1.</span> <span class="toc-text">reduce() 和 reduceRight()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6-新增方法"><span class="toc-number">9.</span> <span class="toc-text">ES6+ 新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#entries-fill-findIndex-includes"><span class="toc-number">9.1.</span> <span class="toc-text">entries() fill() findIndex() includes()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实验中的功能"><span class="toc-number">10.</span> <span class="toc-text">实验中的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#flat"><span class="toc-number">10.1.</span> <span class="toc-text">flat()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie">Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/js实现欧几里得算法/">js实现欧几里得算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/js数组的方法小结/">js数组的方法小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/js实现集合-Set类/">js实现集合(Set类)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/js实现个链表吧/">js实现个链表吧</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/井字棋游戏/">井字棋游戏</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao">Tags</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size:15px">算法</a> <a href="/tags/数组/" style="font-size:15px">数组</a> <a href="/tags/数据结构/" style="font-size:15px">数据结构</a> <a href="/tags/Set/" style="font-size:15px">Set</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive">Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> | <a href="/atom.xml">RSS</a> | <a href="/about/">About</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span>Copyright &copy;<a href="/." rel="nofollow">robert.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>